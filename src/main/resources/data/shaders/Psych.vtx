/*{
	"DESCRIPTION": "Kaleidoscopic psychedelic tunnel with polar swirl and palette cycling",
	"CREDIT": "by tracyscott",
	"ISFVSN": "2.0",
	"CATEGORIES": [
		"VERTEX SDF",
		"PSYCHEDELIC"
	],
	"INPUTS": [
                {
                        "NAME": "plane",
                        "TYPE": "float",
                        "DEFAULT": 0,
                        "MIN": 0,
                        "MAX": 4
                },
		{
			"NAME": "swirl",
			"TYPE": "float",
			"DEFAULT": 0.85,
			"MIN": -3.0,
			"MAX": 3.0
		},
		{
			"NAME": "kalei",
			"TYPE": "float",
			"DEFAULT": 6.0,
			"MIN": 2.0,
			"MAX": 24.0
		},
		{
			"NAME": "zoom",
			"TYPE": "float",
			"DEFAULT": 0.6,
			"MIN": -2.0,
			"MAX": 2.0
		},
		{
			"NAME": "wobble",
			"TYPE": "float",
			"DEFAULT": 0.35,
			"MIN": 0.0,
			"MAX": 2.0
		},
		{
			"NAME": "sat",
			"TYPE": "float",
			"DEFAULT": 0.9,
			"MIN": 0.0,
			"MAX": 1.0
		}
	]
}*/

#version 330

uniform float fTime;
uniform float plane;
uniform float swirl;
uniform float kalei;
uniform float zoom;
uniform float wobble;
uniform float sat;

layout(location = 0) in vec3 position;
out vec3 outColor;

#include <palettes.vti>
#include <sdf2d.vti>
#include <consts.vti>
#include <planeUV.vti>

// Utility: rotate a 2D vector
vec2 rotate2D(vec2 p, float a){
	float c = cos(a), s = sin(a);
	return mat2(c, -s, s, c) * p;
}

// Kaleidoscope fold: mirror angle into a [0, sector] wedge
float kaleidoscopeFold(inout float ang, float slices){
	// Use constants defined in consts.vti
	float twoPi = 2.0 * PI;
	float sector = twoPi / max(2.0, floor(slices));
	ang = mod(ang, twoPi);
	float halfSector = sector * 0.5;
	// Map angle to [-halfSector, halfSector] by mirroring around sector boundaries
	float k = floor((ang + halfSector) / sector);
	float baseAng = ang - k * sector;
	float mirrored = baseAng;
	if (baseAng > halfSector) mirrored = sector - baseAng;
	// return how many sectors we stepped (for optional coloring)
	ang = mirrored;
	return k;
}

void main(){
	// Base UV using plane selector
	vec2 uv = getPlaneUV(position, plane);

	// center and mirror
	uv -= 0.5;
	uv.y = abs(uv.y);

	// Temporal parameters
	float t = fTime;
	float t2 = t * 0.5;
	float zFlow = t * zoom;

	// Normalize to aspect ~1 (assumes square-ish domain), add slight breathing
	float breathe = 0.85 + 0.15 * sin(t * 0.8);
	uv *= breathe;

	// Precompute polar
	float r = length(uv) + 1e-6;
	float a = atan(uv.y, uv.x);

	// Kaleidoscope fold on angle
	float slices = max(2.0, floor(kalei));
	float kidx = kaleidoscopeFold(a, slices);

	// Swirl by radius and time
	float sw = swirl * (0.6 + 0.4 * sin(t * 0.7));
	a += sw * r + 0.35 * sin(3.0 * r - t * 1.1);

	// Convert back to cartesian with wobble
	vec2 p = vec2(cos(a), sin(a)) * r;

	// Multi-frequency wobble and flow
	float wob = wobble;
	p += 0.12 * wob * vec2(sin(4.1 * p.y + t * 1.7), cos(3.7 * p.x - t * 1.3));
	p = rotate2D(p, 0.25 * wob * sin(1.2 * t + 2.0 * r));

	// Radial tunnel coordinate: more rings near center
	float tunnel = log(1.0 + 3.0 * r + 0.25 * sin(4.0 * r + t));
	float bands = tunnel * 12.0 - zFlow * 8.0;

	// Angle-based stripeing to enhance kaleidoscope facets
	float facet = cos((a + 0.15 * sin(t)) * slices);
	float stripe = 0.5 + 0.5 * cos(bands + facet * 2.3 + 1.7 * sin(0.7 * t + r * 5.0));

	// Interference layers
	float layer1 = 0.5 + 0.5 * sin(6.0 * r - zFlow * 4.0 + 1.3 * sin(a * 3.0 + t * 0.9));
	float layer2 = 0.5 + 0.5 * cos(8.0 * r * (1.0 + 0.2 * sin(t)) + 2.1 * a - zFlow * 5.0);

	// Compose density
	float d = mix(layer1, layer2, 0.5) * stripe;
	// Sharpen center bloom
	float center = exp(-8.0 * r * r) * (0.6 + 0.4 * sin(t * 2.0));

	// Palette animation input: combine distance, angle, time for rich motion
	float palT = bands * 0.25 + a * 1.2 + t * 0.8 + 0.35 * sin(2.0 * r + 1.7 * t);
	vec3 colA = paletteN(palT, 2.0);
	vec3 colB = paletteN(palT + 2.7, 4.0);

	// Mix palettes by facet and density
	vec3 baseCol = mix(colA, colB, 0.5 + 0.5 * sin(facet + t * 0.6));
	// Saturation control
	float lumin = dot(baseCol, vec3(0.2126, 0.7152, 0.0722));
	vec3 satCol = mix(vec3(lumin), baseCol, clamp(sat, 0.0, 1.0));

	// Apply density and center bloom
	vec3 finalColor = satCol * (0.25 + 0.85 * d) + vec3(1.0, 0.95, 0.9) * center * 0.6;

	// Subtle ring glow falloff
	float glow = 0.015 / (0.02 + r * r);
	finalColor += glow * paletteN(t * 0.6 + r * 3.0, 3.0) * (0.4 + 0.6 * stripe);

	// Clamp to displayable range
	outColor = clamp(finalColor, 0.0, 1.0);
}